# xv6-k210 操作系统改进总结

> 本文档总结了我对 xv6-k210 操作系统进行的系统性改进工作，涵盖文件系统、内存管理、进程管理、进程间通信等多个核心子系统的功能扩展与性能优化。

---

## 项目概述

xv6 是 MIT 开发的教学用操作系统，代码简洁但功能基础。我们在此基础上进行了深度改进，完成了14项功能改进。这些改进相互关联、相互支撑，比如内存管理的 COW 和 Lazy Allocation 为 mmap 提供基础，进程调度器与信息统计功能紧密配合，整个系统能够作为有机整体运行。

---

## 文件系统方面的改进

### FAT 表缓存

原系统每次访问文件簇链都需从磁盘读 FAT 表，造成大量磁盘 IO。我实现了 32 个扇区的缓存，采用 LRU 淘汰策略，用数组加链表结构实现 O(1) 操作，配合 spinlock 保证线程安全，用 write-through 策略确保数据一致性。预期可减少 50% 以上的磁盘 IO。

### 目录项缓存优化

原有 LRU 结构缺少关键操作：目录项命中后未移到链表头部。我在 `eget` 函数中添加了移动操作，代码量小但效果明显，预期缓存命中率可提高到 70% 以上。

### 文件名排重机制

原系统遇同名文件直接报错。我在 `ealloc` 函数中添加排重逻辑，自动生成 file_1、file_2 等后缀，最多支持 9999 个。实现时未用系统库函数，确保嵌入式环境可用。

### 长文件名转短文件名排重

不同长文件名可能转换为相同短文件名（如"文档 2023.txt"和"文档 2024.txt"都变成"DOCUME~1.TXT"）。我在 `emake` 函数中添加检查，生成 ~1、~2 等后缀，确保向后兼容。

### 时间戳修复

原系统镜像文件时间显示 UTC 时间（晚 8 小时），且时间流逝速度不对。问题出在 Makefile 的 cp 命令和时钟频率假设（390MHz vs QEMU 实际 10MHz）。修正后时间戳正常显示。

---

## 内存管理方面的改进

### Copy-on-Write 机制

原系统 fork 时完全拷贝物理内存，慢且浪费。我实现的 COW 让父子进程先共享物理页，标记为只读和 COW，写入时才分配新页并拷贝。实现难点是引用计数管理，我在 kalloc.c 中维护 ref_count，释放时 decref，归零才真正 free。copyout 路径也需识别 COW 并先分裂，避免内核写污染共享页。意外修复了原系统用户态 panic 的 bug。

### Lazy Allocation 惰性分配

原系统 sbrk 立即分配物理页，但程序可能不会全部使用。我改为只更新 proc->sz 记账，缺页时才分配。好处是 fork 更快、支持稀疏地址空间、避免 fork+exec 模式的无效分配。缺页处理有两条路径：用户态访存触发，以及内核 copyin/copyout 主动调用 lazy_alloc。

### mmap 系统调用

引入 VMA（Virtual Memory Area）数据结构管理多个不相邻的内存区域，每个区域有独立权限和标志。mmap 时不分配物理页（惰性分配），只建 VMA 记录，缺页时查 VMA 表再分配。关键细节：vma_insert 检查地址冲突，vma_find_free_range 从高地址往低地址搜索空闲区域。缺页处理顺序很重要：COW > VMA > sbrk lazy allocation。

---

## 进程管理方面的改进

### 优先级调度

原调度器是简单 Round Robin。我添加 priority 字段（0-100，默认 50），调度器改为两阶段扫描：先找最高优先级，再执行匹配进程。抢占机制在时钟中断实现，每次中断检查有无其他就绪进程，有则让出 CPU。fork 时子进程继承父进程优先级。

### 多级反馈队列调度 MLFQ

优先级调度需手动设置，无法自动适应任务类型。MLFQ 让新进程从最高队列开始，短任务快速完成，CPU 密集型任务慢慢降级。实现 3 级队列，时间片分别为 1、2、4。关键设计：handle_time_slice 只负责递减和降级，调度器负责重置 time_slice，职责分离后逻辑清晰。新进程 time_slice 必须初始化为 0，否则刚创建就降级。

### 进程信息统计

实现了 sys_getprocs() 和 sys_getrusage() 系统调用，以及 ps 和 top 命令。在 trap.c 的时钟中断处理中更新 utime 和 stime，准确统计每个进程的 CPU 使用时间。ps 列出所有进程信息，top 每秒刷新显示实时状态。

---

## 进程间通信方面的改进

### 共享内存 IPC

实现 System V 风格接口：shmget 创建/获取、shmat 附加、shmdt 分离、shmctl 控制。全局维护最多 16 个段，用 spinlock 保护。不同进程虚拟地址可不同，但指向同一物理页，写入立即可见。do_shmdt 通过遍历所有段、用 walk() 查物理地址来匹配，do_shmctl 需检查 ref_count == 0 才允许删除。

### 信号机制（第一阶段）

定义 POSIX 信号类型，通过 signal() 注册处理函数。SIGKILL 和 SIGSTOP 不能被捕获，这是 Unix 的基本安全机制。fork 后子进程继承信号处理函数设置，符合 Unix 语义。用位图表示待处理信号，数组存储处理函数地址。

### 信号机制（第二阶段）

sys_sigkill() 设置 sig_pending 位图，usertrap 中调用 process_signals() 处理。根据信号类型执行不同动作：SIGKILL 设置 killed 标志，SIGSTOP 暂停进程，SIGCONT 恢复进程，SIG_IGN 忽略，SIG_DFL 执行默认操作，用户处理函数则修改 trapframe 跳转。用 signal_ret_pc 保存原始 PC，处理完返回时恢复。SIGSTOP/SIGCONT 用 p->chan 字段区分暂停原因。

---

## 工具和测试

### cachetest 缓存性能测试

创建 3 个 512 字节测试文件，顺序读取 500 次，交替顺序读取 500 次，比较耗时验证缓存效果。

### 其他测试程序

cowtest 测试 COW 的基本功能和多页面场景。lazytest 测试惰性分配。mmaptest 测试内存映射的读写、权限和 COW。priotest 和 mlfqtest 测试调度算法。shmtest 测试共享内存。sigtest1 和 sigtest2 测试信号机制。所有测试覆盖了主要功能，确保代码正确性和稳定性。

---

## 核心创新点和难点

### VMA 管理与双层缺页处理

VMA 是首次在 xv6 中引入的概念，为 mmap 提供基础架构。双层缺页处理（COW > VMA > sbrk lazy allocation）实现了不同内存管理方式的协同，优先级顺序经过多次调试确定。

### 进程内核页表与引用计数

每进程专属内核页表确保内核访问用户空间时具备一致映射关系，避免依赖 SUM。引用计数是 COW 和共享内存的基础，核心原则是物理页释放取决于引用计数归零。调试时常见错误包括初始化未设置 ref、重复释放、计数不匹配等。

### 时间片管理细节

MLFQ 实现的关键是职责分离：handle_time_slice 负责递减和降级，调度器负责重置。新进程 time_slice 必须初始化为 0。信号处理用 signal_ret_pc 保存原始 PC，trap 时恢复，实现从处理函数返回到被中断点。

---

## 改进效果总结

文件系统方面，多级缓存减少磁盘 IO，文件名排重和时间戳修复提升用户体验。内存管理方面，COW、Lazy Allocation、mmap 协同工作，大幅提升内存效率和 fork 性能。进程管理方面，优先级调度和 MLFQ 实现静态到动态的演进，ps/top 提供完善监控。进程间通信方面，信号机制和共享内存提供标准接口。

所有改进经过充分测试，保持 xv6 简洁易懂的风格，可作为操作系统教学和研究的参考。虽然仍有可完善之处（如文件映射、信号掩码、页面换出），但系统已具备基本实用价值。

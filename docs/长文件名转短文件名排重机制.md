# 长文件名转短文件名排重机制

## 1. 问题背景

在 FAT32 文件系统中，长文件名 (LFN) 最长可达 255 个字符，而短文件名 (SFN) 是严格的 8.3 格式。当创建长文件名文件时，系统会自动生成一个对应的短文件名。

文档中提到的“将长文件名转换到短文件名时未排重”指的是：当两个不同的长文件名转换为相同的短文件名时，系统没有采取措施生成不同的短文件名，这会导致较低版本的 FAT 系统无法区分这些文件。

## 2. 问题示例

- 长文件名 `文档 2023.txt` → 转换为 `DOCUME~1.TXT`
- 长文件名 `文档 2024.txt` → 也可能转换为 `DOCUME~1.TXT`
- 两个不同的文件在旧版本 FAT 系统中会显示为同一个文件

## 3. 实现方案

在 `emake` 函数中添加了长文件名转短文件名的排重机制：

1. 首先为当前长文件名生成一个基础短文件名
2. 然后遍历目录中的所有文件，检查是否有其他文件的短文件名与基础短文件名相同
3. 如果存在重复，则生成带有 ~1、~2 等数字后缀的唯一短文件名
4. 确保不同的长文件名始终转换为不同的短文件名

## 4. 核心实现逻辑

```c

// 在 emake 函数中

// 检查目录中是否有重复的短文件名并生成唯一的短文件名

charshortname[CHAR_SHORT_NAME + 1];

charbase_shortname[CHAR_SHORT_NAME + 1];

generate_shortname(base_shortname, ep->filename);

memcpy(shortname, base_shortname, CHAR_SHORT_NAME);


int found_duplicate = 0;

int suffix_num = 1;


do {

    // 假设没有找到重复

    found_duplicate = 0;


    // 遍历目录检查是否有重复的短文件名

    // ... 目录遍历和比较代码 ...


    if (found_duplicate) {

        // 生成带数字后缀的新短文件名

        charsuffix[6];

        suffix[0] = '~';

        // 将数字转换为字符串并添加到短文件名中

        // ... 字符串转换代码 ...


        // 插入后缀到短文件名中

        memcpy(shortname + base_len, suffix, strlen(suffix));

        // ... 填充空格并追加扩展名 ...


        suffix_num++;

    }

} while (found_duplicate);


// 为唯一的短文件名生成校验和

de.lne.checksum = cal_checksum((uchar *)shortname);

```

## 5. 技术特点

### 5.1 标准兼容性

- 符合 FAT32 短文件名格式要求
- 向后兼容旧版本 FAT 系统
- 生成的短文件名格式与 Windows 系统一致

### 5.2 排重规则

- 使用 `~` 作为短文件名的排重分隔符
- 支持的数字范围：1-9999
- 当文件名基础部分过长时，会自动截断以适应后缀

### 5.3 性能考虑

- 仅在目录中存在重复短文件名时才生成带后缀的文件名
- 目录遍历是在内存中进行的，不会导致额外的磁盘 IO
- 排重逻辑的时间复杂度是 O(n)，n 是目录中的文件数量

## 6. 与长文件名排重的区别

| 类型 | 长文件名排重 | 短文件名排重 |
|------|------------|------------|
| 目的 | 防止创建完全相同的长文件名 | 防止不同长文件名转换为相同短文件名 |
| 范围 | 同一个目录下的相同长文件名 | 同一个目录下的不同长文件名 |
| 结果 | 生成 `file.txt_1`、`file.txt_2` 等 | 生成 `FILE~1.TXT`、`FILE~2.TXT` 等 |
| 影响 | 所有支持长文件名的系统 | 仅影响不支持长文件名的旧版本系统 |

## 7. 注意事项

- 短文件名排重仅在需要生成短文件名时发生（即文件名长度超过8.3格式）
- 排重机制是自动的，对用户透明
- 最多支持9999个具有相似长文件名的文件

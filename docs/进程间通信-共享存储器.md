# 共享内存 IPC

xv6 原本只有管道一种 IPC 机制，用起来还行，但数据量大的时候拷贝开销很明显。共享内存是最快的 IPC 方式——没有之一，因为进程直接访问同一块物理内存，根本不经过内核中转。想法很简单，实现起来嘛...折腾了一下午。

## 设计思路

参考了 System V 的接口风格，提供四个系统调用：shmget创建/获取共享内存，shmat附加到进程地址空间，shmdt分离，shmctl控制（主要是删除）。全局维护一个最多 16 个段的小表，用 spinlock 保护并发访问。数据结构大概长这样：

```c
struct shm_segment {
  int id;              // 共享内存标识符
  int key;             // 用户提供的键值
  uint64 pa;           // 物理地址
  uint64 size;         // 大小（字节）
  int ref_count;       // 附加进程计数
  int perm;            // 权限标志（暂未用上）
  int used;            // 是否使用
};
```

shmget的时候用 kalloc()分配物理页，返回一个 shmid。然后各个进程用这个 shmid 调用shmat把这块物理页映射到自己的虚拟地址空间。神奇的地方在于：不同进程的虚拟地址可以不一样（测试里父进程是 0x4000，子进程是 0x5000），但它们指向同一块物理内存，所以一个进程写入，另一个进程能立即看到。

## 具体实现

核心代码都在 [kernel/shm.c](kernel/shm.c) 里。

**shm_init()** 就在系统启动时调用一次，初始化全局锁，把 16 个槽位都标记为 unused，next_id 设为 1。没啥好说的。

**do_shmget()** 是创建/获取共享内存的入口。先拿锁，然后根据 key 查表看是不是已经存在。如果 key != 0 且找到了对应的段，直接返回 ID（这就是"获取已存在共享内存"的路径）。如果没找到，就找个空的槽位，调用 kalloc() 分配一页物理内存，初始化各个字段，返回新分配的 ID。这里有个细节：size 参数会向上取整到页边界，但当前实现只分配了一页，所以不管传多大的 size 都是 4096 字节。这是偷懒了，但够用。

**do_shmat()** 负责把共享内存映射到进程地址空间。先根据 shmid 找到对应的段，然后计算虚拟地址——直接用 PGROUNDUP(p->sz) 找进程堆的末尾。核心是调用 mappages() 建立映射：物理页是 seg->pa，虚拟页是刚才算出来的 va，权限设为 PTE_W | PTE_R | PTE_U（可写可读用户态）。然后更新进程的 sz，增加 ref_count。返回值就是这个虚拟地址，用户态程序拿到后就能当指针用了。

**do_shmdt()** 是反向操作，分离共享内存。麻烦的是参数只有虚拟地址，不知道对应的共享内存段是哪个。解决方案前面说过：遍历所有段，用 walk() 查虚拟地址对应的物理地址，看是否匹配。找到后用 vmunmap() 解除映射（注意最后一个参数传 0，表示不释放物理页，因为物理页是共享的），然后更新进程 sz，减少 ref_count。

**do_shmctl()** 当前只实现了 SHM_RMID 命令，就是删除共享内存。关键是要检查 ref_count == 0，否则拒绝删除（防止还有进程在用就被删掉了）。删除时调用 kfree() 释放物理页，把槽位标记为 unused。

所有操作都在 acquire(&shm_table.lock) 和 release(&shm_table.lock) 之间，保证并发安全。虽然 spinlock 可能影响性能，但共享内存操作不是高频路径，问题不大。

## 遇到的问题

### 坑1：shmdt 的查找逻辑

shmdt 的参数是虚拟地址，但内核需要知道这个地址对应哪个共享内存段。问题是：进程可能附加了多个共享内存段，怎么知道用户传的是哪个？

一开始想了个笨办法：遍历所有共享内存段，对每个段都用 walk() 查用户传的地址，看物理地址是否匹配。这个办法虽然能工作，但效率不怎么样。不过反正只有 16 个段，而且 shmdt 不是高频操作，凑合用吧。

更优雅的做法应该是在 struct proc 里维护一个共享内存列表，记录这个进程附加了哪些段。但那样改动太大，懒得搞了。

### 坑2：地址选择

shmat 的 addr 参数在 System V 里是可以指定附加地址的，但当前实现直接忽略了这个参数，强制把共享内存放在进程地址空间末尾（PGROUNDUP(p->sz)）。这个简化是有意为之——支持用户指定地址需要检查地址是否已被占用、是否对齐等一堆边界条件，太麻烦。

测试里父进程拿到 0x4000，子进程拿到 0x5000，是因为 fork 之后子进程的 sz 已经增长过了（父进程 attach 了一次），所以子进程 attach 时地址往后挪了。这不是 bug，是正常现象。

## 测试结果

测试程序跑通了，输出如下：

![进程间通信结果](image/进程间通信-共享存储器/进程间通信结果.png)

**结果分析：**

父进程成功创建并附加共享内存后写入初始数据，数据内容能被完整读出，说明共享内存可写、映射正常。fork之后，子进程再次通过同一个 shmid附加共享内存，虽然映射到不同的虚拟地址，但能读到父进程写入的数据，这一点验证了父子进程确实共享同一块物理内存，而不是拷贝。

子进程修改共享内存内容并退出后，父进程在不重新映射的情况下直接读到了修改后的数据，说明跨进程写入是即时可见的，没有触发 copy-on-write，共享语义成立。

最后父子进程都正常 shmdt，父进程成功删除共享内存，生命周期完整、无异常。整体来看，共享内存的创建、映射、读写一致性和回收流程都验证通过。

## 修改的文件

- [kernel/shm.c](kernel/shm.c) - 新增，核心实现
- [kernel/include/sysnum.h](kernel/include/sysnum.h) - 加了 4 个系统调用号（29-32）
- [kernel/syscall.c](kernel/syscall.c) - 注册系统调用、写包装函数
- [kernel/main.c](kernel/main.c) - main() 里加 shm_init()
- [kernel/include/vm.h](kernel/include/vm.h) - 加了 walk() 函数声明（这个坑了我半天）
- [xv6-user/user.h](xv6-user/user.h) - 用户态函数声明、常量定义
- [xv6-user/usys.pl](xv6-user/usys.pl) - 生成系统调用存根
- [Makefile](Makefile) - 编译列表加 kernel/shm.o 和 _shmtest
- [xv6-user/shmtest.c](xv6-user/shmtest.c) - 测试程序

总体来说，虽然有些简化，但基本功能是可用的。

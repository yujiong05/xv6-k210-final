# 内存管理的惰性分配 与 COW + 进程内核页表改造说明

> 适用范围：xv6-k210 分支在 **QEMU RISC-V virt** 平台运行（OpenSBI 引导），并完成 **Lazy Allocation（按需分配）**、与 **Copy-On-Write（COW）** 协同、以及 **每进程内核页表（kpagetable）** 的一致性改造与测试闭环。

---

## 1. 项目概述

本项目基于 xv6（RISC‑V 版本）进行工程化扩展，目标是让用户态虚拟地址空间的扩展更“轻”，并与 fork/COW/系统调用的拷贝路径、以及用户栈 guard page 机制保持一致。

已完成的关键能力：

-**Lazy Allocation（按需分配）**

  `sbrk(n>0)` 仅增加 `proc->sz` 记账，不立即分配物理页；首次触达（load/store）或内核 copyin/copyout 访问到缺页地址时再分配物理页并建立映射。

-**与 COW 协同的缺页处理**

  fork 后共享物理页：父子页表清 `PTE_W`、置 `PTE_COW`；写缺页触发复制。

-**每进程内核页表（kpagetable）**

  在进程进入内核态时使用该进程专属的内核页表，确保内核在访问用户地址空间（例如 copyin/copyout 或懒分配映射）时具备一致映射关系，同时避免依赖 `SUM`。

-**Guard page（用户栈保护页）**

  exec 时为用户栈保留 guard page（通过 `uvmclear` 清除 `PTE_U`），缺页路径必须识别并拒绝为 guard page “补页”。

---

## 2. 术语与核心约束

-**用户地址空间上界**：`MAXUVA / MAXVA`（以工程定义为准，需确保与页表层级一致）。

-**缺页异常类型**：用户态常见为

  -`scause=13`（Load page fault）

  -`scause=15`（Store/AMO page fault）

-**缺页地址来源**：`stval` 提供触发缺页的虚拟地址（RISC‑V 特权寄存器）。

-**一致性约束**：用户页表 `pagetable` 与进程内核页表 `kpagetable` 对用户空间映射必须保持一致（除 `PTE_U` 等特权位差异）。

---

## 3. 软件架构

### 3.1 启动链路（QEMU virt）

```

QEMU (virt machine)

   ↓  (firmware)

OpenSBI (S-mode 引导与 SBI 服务)

   ↓

xv6 kernel (S-mode)

   ↓

init (pid=1)

   ↓

sh / user programs

```

### 3.2 模块边界

-`kernel/trap.c`：usertrap/kerneltrap，缺页分发与异常治理（kill/alloc/cow）

-`kernel/vm.c`：页表走访（walk）、映射（mappages）、解除映射（uvmunmap/uvmdealloc）、拷贝路径（copyin/copyout/copyinstr）、COW（uvmcopy/cow_alloc）

-`kernel/sysproc.c`：`sys_sbrk` 语义改造（记账 vs 物理分配）

-`kernel/kalloc.c`：物理页分配器 + **引用计数**（refcount）

-`kernel/proc.c`：进程生命周期（allocproc/freeproc/fork/exit）与 `kpagetable` 生命周期

---

## 4. 设计原理与实现细节

### 4.1 Lazy Allocation：从“立刻分配”到“先记账，后兑现”

**目标**：降低 `sbrk` 扩容时的物理内存占用与分配开销，同时允许“稀疏”地址空间（sparse heap）。

#### 4.1.1 `sys_sbrk` 语义

-`n >= 0`：只更新 `p->sz = oldsz + n`（需检查溢出与上界），不调用 `uvmalloc`。

-`n < 0`：收缩堆，调用 `uvmdealloc` 解除映射并回收物理页。

#### 4.1.2 缺页补页触发点（两条主路径）

1)**用户态真实访存触发缺页**：在 `usertrap` 内捕获 `scause=13/15`，根据 `stval` 对齐到页边界后补页。

2)**内核拷贝路径触发缺页**：`copyin/copyout/copyinstr` 对 `walkaddr` 失败的地址，在确认 `va < p->sz` 且不是 guard page 的情况下触发 `lazy_alloc`。

> 这样做的价值：内核路径（read()/write()/exec 参数拷贝等）不依赖用户态先触发缺页，避免“读入到未触达页”这类场景失败。

---

### 4.2 Page Fault 处理策略（usertrap）

缺页处理的治理策略（按优先级）：

1.**越界/非法地址**：`va >= MAXUVA` 或 `va >= p->sz` → `p->killed=1`

2.**写缺页且命中 COW**：`scause==15 && PTE_COW` → `cow_alloc()`

3.**空洞（lazy 未映射）**：`pte==0 或 !PTE_V` → `lazy_alloc()`

4.**已映射但权限失败**：通常是 guard page 或非法访问 → kill

---

### 4.3 COW：fork 的“共享 + 写时复制”

#### 4.3.1 `uvmcopy` 策略

- 遍历 `[0, sz)` 的用户地址空间：

  - 跳过未映射页（lazy 空洞）
  - 对可写页：父子双方清 `PTE_W`，置 `PTE_COW`，并让子进程映射到同一物理页
  - 引用计数 `incref(pa)`

> 与 Lazy 的协同点：**uvmcopy 必须允许“空洞”存在**，不应因某页 `walk()==0` 而 panic。

#### 4.3.2 `cow_alloc` 策略

- 为写入页分配新物理页
- 复制旧页内容
- 旧页 `decref(old_pa)`；新页 ref=1
- 更新用户页表 PTE：清 `PTE_COW`、置 `PTE_W`
- 同步更新 `kpagetable` 中对应映射（通常不带 `PTE_U`）

---

### 4.4 进程内核页表（kpagetable）：一致性与性能的折中

#### 4.4.1 生命周期

-`allocproc()`：创建 `pagetable`（用户页表）与 `kpagetable`（拷贝自全局 `kernel_pagetable` 后做进程专属修补）

-`freeproc()`：释放 `kpagetable` 与 `pagetable`，并通过 `uvmfree/vmunmap` 回收用户空间已映射页

#### 4.4.2 为什么需要 kpagetable？

- 内核在 S-mode 下执行，对用户虚拟地址的访问必须在当前页表下可翻译

  典型场景：`copyin/copyout/copyinstr`、lazy_alloc 需要在内核态对用户 VA 建映射、fork/exec 等。
- 通过保持 `kpagetable` 对用户空间的镜像映射，可减少对 `SUM` 的依赖，减少复杂度，并降低页表切换风险。

---

### 4.5 引用计数策略（refcount）：避免双重释放与泄漏

核心原则：**物理页的释放取决于引用计数归零**。

-`kalloc()`：从 freelist 取页，并将 ref 初始化为 1（或等效 incref）

-`incref(pa)`：共享映射（如 COW）时增加引用

-`kfree(pa)`：先检查 ref>=1，再 `decref`；当 ref==0 时才将页挂回 freelist

#### 4.5.1 典型风险与治理

-**panic: kfree: ref < 1**

  代表出现“未持有引用却释放”的路径，常见根因：

  -`freerange()` 初始化阶段未正确设置 ref=1 就调用 kfree

  -`uvmunmap()`/`vmunmap()`/`uvmfree()` 既 decref 又 kfree（重复）

- COW 路径对旧页 decref 次数不匹配

---

## 5. 关键接口与行为契约

### 5.1 `lazy_alloc(pagetable, kpagetable, va)`

- 输入：对齐后的 `va`（用户虚拟页起始地址）
- 行为：

  -`kalloc()` 分配物理页并清零

  - 在 `pagetable` 建立 `PTE_U | PTE_R | PTE_W`
  - 在 `kpagetable` 建立 `PTE_R | PTE_W`（通常不带 `PTE_U`）

  -`sfence_vma()` 刷新 TLB

### 5.2 `uvmunmap(pagetable, va, npages, do_free)`

- Lazy 兼容：允许 `pte==0` 或 `!PTE_V` 时跳过（空洞）

-`do_free==1`：对物理页做 `decref`（若 ref==0 则最终进入 freelist）

### 5.3 Guard page 约束

- exec 设置：

  - 分配 2 页：guard + stack

  -`uvmclear(pagetable, guard_va)` 清 `PTE_U`
- 缺页策略：**不得为 guard page 调 `lazy_alloc`**，否则 stacktest 会失败。

---

## 6. 使用说明（构建、运行与验证）

### 6.1 构建与运行（QEMU）

典型流程（建议全量重建）：

```bash

makeclean

makebuildplatform=qemu

makefsplatform=qemu

makerunplatform=qemu

```

> 说明：`make clean` 会清理用户程序产物；务必先 `make build` 再 `make fs`，确保 fs.img 中打包的是最新 ELF。

### 6.2 功能验证

#### 6.2.1 Lazy Allocation 基线测试

在 xv6 shell 中运行：

```sh

lazytest

```

输出结果：

![内存管理-惰性分配结果图片](docs/image/内存管理-惰性分配/内存管理-惰性分配_图片.png)

---

## 7. 常见问题与排障（高频）

### 7.1 `exec lazytest failed`

优先排查三件事：

1)**fs.img 是否包含 lazytest**

   在 xv6 内 `ls` 查看 lazytest 是否存在且大小正常；若缺失或 size=0，说明打包阶段有问题。

2)**UPROGS/Makefile 是否包含 lazytest**

   确认用户程序列表中有 `lazytest`。

3)**重建 fs.img**

   删除旧镜像后重建（避免缓存/旧文件残留）：

```bash

rm-ffs.img

makeclean

makebuildplatform=qemu

makefsplatform=qemu

makerunplatform=qemu

```

### 7.2 `panic: kfree: ref < 1`

这是 refcount 体系的“红灯”。排查顺序：

1)`refinit()` 是否早于 `freerange()` 执行

2)`freerange()` 是否保证每个物理页在 `kfree()` 前 ref>=1

3)`uvmunmap/vmunmap/uvmfree` 是否出现 “decref + kfree” 的重复释放

4) COW：`incref` 与 `decref` 次数是否严格对称

### 7.3 `kerneltrap` / `scause=0xd`（load fault in S-mode）

含义：**内核态访问了一个当前页表不可翻译的地址**。常见根因：

-`kpagetable` 未包含必要映射（例如用户页镜像、或某段内核映射被覆盖）

-`copyin/copyout` 访问用户 VA 时当前 `satp` 不是预期的 `kpagetable`

- 指针被写坏（例如被 0x040404... 这类填充模式污染）

建议动作：

- 用 `addr2line` 对 `sepc` 回溯定位具体指令
- 在可疑路径加日志（仅 debug 模式），确认 `satp` 与 `kpagetable` 生效

### 7.4. 测试矩阵与验收标准

| 维度   | 验收项            | 通过标准               |
| ------ | ----------------- | ---------------------- |
| 功能   | Lazy Allocation   | lazytest PASS          |
| 稳定性 | 长时间 shell 操作 | 无 kerneltrap/panic    |
| 内存   | fork/exit 压测    | 无 “lost free pages” |

---

## 9. 参考文献

1. MIT PDOS. *xv6: a simple, Unix-like teaching operating system*（RISC‑V 版本教材与源码说明）
2. QEMU Project. *RISC‑V “virt” machine documentation*（virt 板级设备模型、CLINT/PLIC/UART/virtio 等）
3. RISC‑V International. *RISC‑V Privileged Architecture Specification*（异常、scause/stval、页表与特权寄存器语义）
4. OpenSBI Project. *OpenSBI platform & firmware documentation*（SBI 固件实现与 QEMU virt 启动链路）
